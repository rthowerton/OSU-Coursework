\documentclass[10pt,draftclsnofoot,onecolumn]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage[margin=.75in,letterpaper]{geometry}
\usepackage{cite}
\usepackage{bibentry}
\linespread{1.0}

% Title Page
\title{CS444 Writing Assignment 2}
\author{Ryan Howerton \\ Spring 2018}

\begin{document}
	\maketitle
    \newpage
    %Introduce concept of I/O.
    Input and Output (usually abbreviated as I/O to represent their functional correlation) are the way devices communicate on a computer. Respectively, input is information received and processed by a device, and output is information generated by a device. This information is, at its most basic level, instructions in the form of a series of bits that are interpreted by a device that tell it to perform some action. The best example of this is a keyboard: when a user pushes a key, it sends data to the computer that the computer then interprets in different ways, depending on the final destination (e.g. this data may be a character to be displayed, or it could be a command for a game). Ultimately, I/O has the same result on any machine, but different operating systems provide I/O functionality in different ways. A few well-known operating systems will be compared to showcase this: Linux, FreeBSD, and Windows.
    \par
    %How Linux approaches it.
    I/O objects in Linux are essentially entirely abstracted to files, which is a philosophy called "everything-is-a-file". Therefore, any communication done between two devices is viewed by the operating system as being done through a file, though the object in question is not a "regular file". A regular file is the same thing as what a human would call a file: a series of bytes. However, it is worth mentioning that Linux does not impose any formatting on this series of bytes, it just knows that the file contains data.\par
    There are essentially four types of special files (not regular files) in Linux: block device files, character device files, named pipes (FIFOs), and sockets. The device files exist and act like regular files. This allows the user to control devices using the filesystem. Character device files are "accessed as a linear queue of bytes. The device driver places bytes onto the queue, one by one, and user space reads the bytes in the order that they were placed on the queue"\cite{love_2014}. A good example of this would be a user typing on a keyboard. "A block device, in contrast, is accessed as an array of bytes. The device driver maps the bytes over a seekable device, and user space is free to access any valid bytes in the array, in any order—it might read byte 12, then byte 7, and then byte 12 again"\cite{love_2014}. Memory is a good example of a block device. In this way, Linux I/O is done in two different ways, but can primarily be seen as block I/O: a block of data being passed around as explained above. Stream devices are primarily used for communicating with the outside world.\newline
    \par
    %research to be referenced
    %In order to be accessed, a file must first be opened. Files can be opened for reading, writing, or both. An open file is referenced via a unique descriptor, a mapping from the metadata associated with the open file back to the specific file itself. Inside the Linux kernel, this descriptor is handled by an integer called the file descriptor. File descriptors are shared with user space, and are used directly by user programs to access files. A large part of Linux system programming consists of opening, manipulating, closing, and otherwise using file descriptors.
	%Linux provides a system call to create a special file. Device access in Unix systems is performed via device files, which act and look like normal files residing on the filesystem. Device files may be opened, read from, and written to, allowing user space to access and manipulate devices (both physical and virtual) on the system. Named pipes (often called FIFOs, short for “first in, first out”) are an interprocess communication (IPC) mechanism that provides a communication channel over a file descriptor, accessed via a special file. Regular pipes are the method used to “pipe” the output of one program into the input of another; they are created in memory via a system call and do not exist on any filesystem. Named pipes act like regular pipes but are accessed via a file, called a FIFO special file. Unrelated processes can access this file and communicate. Sockets are the final type of special file. Sockets are an advanced form of IPC that allow for communication between two different processes, not only on the same machine, but even on two different machines. In fact, sockets form the basis of network and Internet programming. Whereas sockets communicating over the Internet might use a hostname and port pair for identifying the target of communication, Unix domain sockets use a special file residing on a filesystem, often simply called a socket file.
    %The kernel maintains a per-process list of open files, called the file table. This table is indexed via nonnegative integers known as file descriptors. Each entry in the list contains information about an open file, including a pointer to an in-memory copy of the file’s backing inode and associated metadata, such as the file position and access modes. Both user space and kernel space use file descriptors as unique cookies: opening a file returns a file descriptor, while subsequent operations (reading, writing, and so on) take the file descriptor as their primary argument.
    %Unless the process explicitly closes them, every process by convention has at least three file descriptors open: 0, 1, and 2. File descriptor 0 is standard in (stdin), file descriptor 1 is standard out (stdout), and file descriptor 2 is standard error (stderr). Normally, stdin is connected to the terminal’s input device (usually the user’s keyboard) and stdout and stderr are connected to the terminal’s display. Users can redirect these standard file descriptors and even pipe the output of one program into the input of another. This is how the shell implements redirections and pipes.
    %File descriptors can reference more than just regular files. Indeed, file descriptors are used for accessing device files and pipes, directories and futexes, FIFOs and sockets—following the everything-is-a-file philosophy, just about anything you can read or write is accessible via a file descriptor.
    %By default, a child process receives a copy of its parent’s file table. The list of open files and their access modes, current file positions, and other metadata are the same, but a change in one process—say, the child closing a file—does not affect the other process’s file table.\cite{love_2014}\newline
    \par
    %How FreeBSD approaches it.
    FreeBSD operates under very similar circumstances to Linux, but with a slight change: "The basic model of the UNIX I/O system is a sequence of bytes that can be accessed either randomly or sequentially. For the purposes of most programs, the I/O data model is simplified to just a stream of data bytes, or an I/O stream"\cite{mckusick_neville-neil_watson_mckusick_2015}. FreeBSD uses the more traditional approach of Unix, and transports all data sequentially.
    Like Linux, FreeBSD uses file descriptors to reference files (because of the fact that all I/O is done using streams, files can themselves be viewed as streams). All streams can be opened, written to, read from, and closed just like in Linux. Like Linux, there are a few different kinds of I/O stream objects including the aforementioned (regular) files, pipes/FIFOs, and sockets, which operate much the same way.\newline
    \par
    %Research to be referenced
    %The kernel keeps a descriptor table for each process, which is a table that the kernel uses to translate the external representation of a descriptor into an internal representation. The main ways that a process can obtain a descriptor are by opening or creating an object, or by inheriting from the parent process.
    %Most processes expect three descriptors to be open already when they start running. These descriptors are 0, 1, and 2, more commonly known as standard input, standard output, and standard error, respectively. Usually, all three are associated with the user’s terminal by the login process, and are inherited through fork and exec by processes run by the user. Thus, a program can read what the user types by reading standard input, and the program can send output to the user’s screen by writing to standard output. The standard error descriptor also is open for writing and is used for error output, whereas standard output is used for ordinary output.
    %These (and other) descriptors can be mapped to objects other than the terminal; such mapping is called I/O redirection, and all the standard shells permit users to do it. The shell can direct the output of a program to a file by closing descriptor 1 (standard output) and opening the desired output file to produce a new descriptor 1. It can similarly redirect standard input to come from a file by closing descriptor 0 and opening the file.
    %In addition to the traditional read and write system calls, 4.2BSD introduced the ability to do scatter-gather I/O. Scatter input uses the readv system call to allow a single read to be placed in several different buffers. Conversely, the writev system call allows several different buffers to be written in a single atomic write. Instead of passing a single buffer and length parameter, as is done with read and write, the process passes in a pointer to an array of buffers and lengths, along with a count describing the size of the array."\cite{mckusick_neville-neil_watson_mckusick_2015}\newline
    \par
    %How Windows approaches it.
    Despite being historically separate from Unix-like operating systems, Windows approaches I/O in a startlingly familiar way. Windows too abstracts its device I/O to files, in an attempt to provide a common interface for all devices. The main difference from the previous two operating systems is, again, the standard unit of data that is passed around. Windows uses packets, called I/O Request Packets or IRPs, which can be passed between devices, and completely describes the I/O request. The goal of this design is to "allow an individual application thread to manage multiple I/O requests concurrently"\cite{russinovich_solomon_ionescu_2012}.
    I/O devices are managed by a construct called the I/O manager. When an I/O request is to be made, "The I/O manager creates an IRP in memory to represent an I/O operation, passing a pointer to the IRP to the correct driver and disposing of the packet when the I/O operation is complete"\cite{russinovich_solomon_ionescu_2012}. When the targeted device receives the IRP pointer, it dereferences the IRP in memory, performs the requested operation, then passes the IRP back to the I/O manager either because the operation is finished or more processing needs to be done by other devices.\newline
    \par
    %Included features: Uniform security and naming across devices to protect shareable resources, High-performance asynchronous packet-based I/O to allow for the implementation of scalable applications, Services that allow drivers to be written in a high-level language and easily ported between different machine architectures, Layering and extensibility to allow for the addition of drivers that transparently modify the behavior of other drivers or devices, without requiring any changes to the driver whose behavior or device is modified, Dynamic loading and unloading of device drivers so that drivers can be loaded on demand and not consume system resources when unneeded, Support for Plug and Play, where the system locates and installs drivers for newly detected hardware, assigns them hardware resources they require, and also allows applications to discover and activate device interfaces, Support for power management so that the system or individual devices can enter low power states, Support for multiple installable file systems, Windows Management Instrumentation (WMI) support and diagnosability so that drivers can be managed and monitored through WMI applications and scripts.
    
    %research to reference
    %A device driver typically provides an I/O interface for a particular type of device. A driver is a software module that interprets high-level commands, such as read or write, and issues low-level, device-specific commands, such as writing to control registers. Device drivers receive commands routed to them by the I/O manager that are directed at the devices they manage, and they inform the I/O manager when those commands are complete. Device drivers often use the I/O manager to forward I/O commands to other device drivers that share in the implementation of a device’s interface or control.
    %Most I/O operations don’t involve all the components of the I/O system. A typical I/O request starts with an application executing an I/O-related function (for example, reading data from a device) that is processed by the I/O manager, one or more device drivers, and the HAL.
    %As just mentioned, in Windows, threads perform I/O on virtual files. A virtual file refers to any source or destination for I/O that is treated as if it were a file (such as files, directories, pipes, and mailslots). The operating system abstracts all I/O requests as operations on a virtual file, because the I/O manager has no knowledge of anything but files, therefore making it the responsibility of the driver to translate file-oriented comments (open, close, read, write) into device-specific commands. User-mode applications call documented functions, which in turn call internal I/O system functions to read from a file, write to a file, and perform other operations. The I/O manager dynamically directs these virtual file requests to the appropriate device driver.
    %Most I/O operations that applications issue are synchronous (which is the default); that is, the application thread waits while the device performs the data operation and returns a status code when the I/O is complete. The program can then continue and access the transferred data immediately. When used in their simplest form, the Windows ReadFile and WriteFile functions are executed synchronously. They complete the I/O operation before returning control to the caller. Asynchronous I/O allows an application to issue multiple I/O requests and continue executing while the device performs the I/O operation. This type of I/O can improve an application’s throughput because it allows the application thread to continue with other work while an I/O operation is in progress.
    %Regardless of the type of I/O request, internally I/O operations issued to a driver on behalf of the application are performed asynchronously; that is, once an I/O request has been initiated, the device driver returns to the I/O system. Whether or not the I/O system returns immediately to the caller depends on whether the handle was opened for synchronous or asynchronous I/O."\cite{russinovich_solomon_ionescu_2012}\newline
    %The above information is from Windows Internals, Part 2
    \par
    %Conclusion
    Between each of the three operating systems, Linux, FreeBSD, and Windows, though they read information differently (Linux uses blocks of data, FreeBSD uses a byte stream, and Windows uses the I/O Request Packet), they perform I/O operations in the same way: through treating every data structure as a file. Each of the operating systems keeps track of their structures as a type of file, and uses different operations to read from and write to the file, so as to communicate between processes. They each support two methods of I/O, synchronous vs asynchronous (a process writes to a file while another process reads from it as data is presented vs a process can write to a file then continue its operation and another process can read from it as it needs).
	\newpage
    \bibliographystyle{IEEEtran}
	\bibliography{references.bib}
\end{document}