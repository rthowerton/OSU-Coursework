\documentclass[10pt,draftclsnofoot,onecolumn]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage[margin=.75in,letterpaper]{geometry}
\usepackage{cite}
\usepackage{bibentry}
\linespread{1.0}

% Title Page
\title{CS444 Final Paper}
\author{Ryan Howerton \\ Spring 2018}

\begin{document}
	\maketitle
    \newpage
    
	%--------------------------------------------------------------
    % Introduction
    %--------------------------------------------------------------
    Google defines an operating system as "the software that supports a computer's basic functions, such as scheduling tasks, executing applications, and controlling peripherals." The operating system is the software that lies between the user and hardware, controlling the innards of the computer at a higher level, and interfacing with the user and devices to receive input and provide output. Of course, this is a highly simplistic view of an OS, ignoring their components such as the kernel or the shell, which respectively perform those previous functions. There are many core concepts to grasp when studying operating systems, more than can be discussed in a timely fashion, so to understand how an operating system does its job one must look at a variety of their functions, from a few different perspectives. To that end Linux (an off-shoot of UNIX), FreeBSD (a direct descendant of UNIX, closely related to MacOS), and Microsoft Windows (a successful operating system unrelated to UNIX) will be good perspectives for studying how operating systems schedule processes, perform input/output operations, and manage memory.\par
    
    %--------------------------------------------------------------
    % Processes, Threads, and CPU Scheduling
    %--------------------------------------------------------------
    %Introduce concept of processes and threads as explained by each source.
    When a human looks at a running computer and sees things happen on the screen, they are seeing a multitude of programs being executed and data displayed. A computer program is a set of instructions that, when executed, performs some predefined task. A program in execution is called a process. A process has at least one thread, and possibly more, executing the process's code. However, unless the computer in question has a multi-core processor, threads do not actually run at the same time, but are merely allowed enough execution time on the central processing unit (CPU) to give the illusion of concurrent execution. The entity behind this resource allocation is aptly called a CPU scheduler, and allows threads time on the CPU based on their importance to the continued functioning of the computer and its tasks. Every operating system (OS) provides this functionality to some extent, but Linux, FreeBSD, and Microsoft Windows are prime candidates for exploring scheduling.\par
    %How Linux approaches them.
    Linux is one of if not the most widely distributed operating system in the world. According to Klint Finley of Wired, over a third of all web servers run some form of Linux, 84\% of all smart-phones use Android (which is based in Linux), and many more devices have it included \cite{finley_2017}. Linux does not differentiate between processes and threads. Linux therefore schedules threads, not processes. There are two types of threads: user threads and kernel threads (relating to higher level user-space programs and lower-level system or kernel programs, respectively). Only the kernel can start and stop kernel threads, and their primary function is to keep a system running. Threads in Linux are represented as objects, and are stored in a circular doubly-linked list for reference.\par
    As mentioned previously, while there may be more than one thread currently active, only one thread can be performing its task on a single core at any moment. This is where CPU scheduling comes into play, which is a function of the kernel. "Linux implements preemptive multitasking. Meaning, the scheduler decides when one process ceases running and the other begins...Preemptions are caused by timer interrupts" \cite{Ishkov_2015}. Tasks are split into two categories: I/O bound and processor bound. The latter heavily uses whatever time is dedicated to them, while the former blocks on I/O and so only lightly use their dedicated time slots. "A scheduling policy in the system has to balance between the two types of processes, and to make sure that every task gets enough execution resources, with no visible effect on the performance of other jobs" \cite{Ishkov_2015}.\par
    "To maximize CPU utilization and to guarantee fast response times, Linux tends to provide non-interactive processes with longer “uninterrupted” slices in a row, but to run them less frequently. I/O bound tasks, in turn, possess the processor more often, but for shorter periods of time" \cite{Ishkov_2015}. Processes are assigned priority values to determine how much time the scheduler should afford them. These priority values are determined by how important they are to system function/process execution, and scheduling is controlled by policy groups that control how much time on-average processes get on the CPU \cite{Ishkov_2015}. This holds true for all processes, both user-developed and kernel-level.\par
    Priority values are not entirely static. In fact, a process/thread has two priority values: a static one assigned to it at creation, and a dynamic one that changes as is necessary. The dynamic priority value is equal to the static value at the beginning, but can change depending on the circumstances. For example, if the thread enters into a critical segment, the thread's priority can rise to the maximum so that it does not get interrupted.\par
    %How FreeBSD approaches them.
    FreeBSD is a distribution of BSD, which in turn is a branch of UNIX developed for research purposes at the University of Berkeley. As mentioned previously, MacOS was developed from BSD, and so is a close relative of FreeBSD. While FreeBSD and Linux originated from the same source, they have slightly different approaches to process management.\par
    First, while Linux separates its user and kernel threads for different system uses, FreeBSD assigns its processes kernel-space resources. "Every thread running in the process has a corresponding kernel thread, with its own kernel stack that represents the user thread when it is executing in the kernel as a result of a system call, page fault, or signal delivery" \cite{mckusick_neville-neil_watson_mckusick_2015}. Because of this, a thread can operate in two modes: standard application execution, or calls to the operating system via system calls through the kernel.\par
    Second, while Linux operates almost exclusively on the thread level, FreeBSD maintains both a process structure and a thread structure. The difference is as follows: "the process structure contains information that must always remain resident in main memory, along with references to other structures that remain resident, whereas the thread structure tracks information that needs to be resident only when the process is executing such as its kernel run-time stack" \cite{mckusick_neville-neil_watson_mckusick_2015}.\par
    However, FreeBSD schedules processes and threads very similarly to Linux (ignoring the separation of the two objects). FreeBSD makes use of both scheduling priority values and policies. Like Linux, FreeBSD gives I/O bound tasks short periods of computation, followed by long periods of idling, and non-interactive processes longer periods of computation, but a lower priority so that other less active processes are allowed time. Like Linux, task priority is regularly recalculated to allow fair CPU time allocation, so "jobs that use large amounts of CPU time sink rapidly to a low priority, whereas interactive jobs that are mostly inactive remain at a high priority so that, when they are ready to run, they will preempt the long-running lower-priority jobs" \cite{mckusick_neville-neil_watson_mckusick_2015}.\par
    %How Windows approaches them.
    While Windows was developed separately from UNIX, and consequently Linux and FreeBSD, the Windows system scheduler schedules tasks in much the same fashion. That is, "the system scheduler controls multitasking by determining which of the competing threads receives the next processor time slice. The scheduler determines which thread runs next using scheduling priorities"\cite{Scheduling}. Priority levels are assigned based on the priority class of its parent process and the priority level of the thread within the priority class of its parent process (a priority class is a special construct in Windows, created for this purpose). Each thread is assigned a priority level between 0 and 31, with 0 being lowest priority (reserved for the zero-page thread, which zeros pages no longer in use) and 31 being highest. CPU time is assigned to threads round robin style for all threads of the same level, starting with the highest priority level, and decreasing. If a thread with a higher priority becomes ready to run, they interrupt lower priority threads and the scheduler gives them a full time slot. The higher priority thread will then run to completion, and the lower priority thread will resume.\par
    Windows threads have two different types of priority, as did the two previous examples: base priority and dynamic priority. The base priority is assigned to it as described above, and dynamic priority is initially equal to the base priority. However, "the system can boost or lower the dynamic priority to ensure that it is responsive and that no threads are starved for processor time"\cite{Scheduling}. This is called priority boosting, and it can only happen to those threads with base priority between 0 and 15. Consequently, this dynamic priority is the number used to schedule a thread, while the base priority is used to initialize a thread.\par
    The three example operating systems, Linux, FreeBSD, and Microsoft Windows are unsurprisingly different in their approaches to threading and scheduling. Linux operates exclusively on threads, treating all threads as unique entities. FreeBSD is similar, but gives each thread two layers of operation (one thread has both user-space and kernel-space). Windows treats threads as the children of processes. However, all three operate on the concept of process priority values, and assign a number to each process that the scheduler uses to assign operation time to each thread. This theme of different yet similar becomes more prevalent in studying one of the most important functions of an operating system: input/output.\par
        
    %--------------------------------------------------------------
    % I/O and provided functionality
    %--------------------------------------------------------------
    %Introduce concept of I/O.
    Input and Output (usually abbreviated as I/O to represent their functional correlation) are the way devices communicate on a computer. Respectively, input is information received and processed by a device, and output is information generated by a device. This information is, at its most basic level, instructions in the form of a series of bits that are interpreted by a device that tell it to perform some action. The best example of this is a keyboard: when a user pushes a key, it sends data to the computer that the computer then interprets in different ways, depending on the final destination (e.g. this data may be a character to be displayed, or it could be a command for a game). Ultimately, I/O has the same result on any machine, but different operating systems provide I/O functionality in different ways.\par
    %How Linux approaches it.
    I/O objects in Linux are essentially entirely abstracted to files, which is a philosophy called "everything-is-a-file". Therefore, any communication done between two devices is viewed by the operating system as being done through a file, though the object in question is not a "regular file". A regular file is the same thing as what a human would call a file: a series of bytes. However, it is worth mentioning that Linux does not impose any formatting on this series of bytes, it just knows that the file contains data.\par
    There are essentially four types of special files (not regular files) in Linux: block device files, character device files, named pipes (FIFOs), and sockets. The device files exist and act like regular files. This allows the user to control devices using the file system. Character device files are "accessed as a linear queue of bytes. The device driver places bytes onto the queue, one by one, and user space reads the bytes in the order that they were placed on the queue"\cite{love_2014}. A good example of this would be a user typing on a keyboard. "A block device, in contrast, is accessed as an array of bytes. The device driver maps the bytes over a seekable device, and user space is free to access any valid bytes in the array, in any order--it might read byte 12, then byte 7, and then byte 12 again"\cite{love_2014}. Memory is a good example of a block device. In this way, Linux I/O is done in two different ways, but can primarily be seen as block I/O: a block of data being passed around as explained above. Stream devices are primarily used for communicating with the outside world.\par
    %How FreeBSD approaches it.
    FreeBSD operates under very similar circumstances to Linux, but with a slight change: "The basic model of the UNIX I/O system is a sequence of bytes that can be accessed either randomly or sequentially. For the purposes of most programs, the I/O data model is simplified to just a stream of data bytes, or an I/O stream"\cite{mckusick_neville-neil_watson_mckusick_2015}. FreeBSD uses the more traditional approach of Unix, and transports all data sequentially.
    Like Linux, FreeBSD uses file descriptors to reference files (because of the fact that all I/O is done using streams, files can themselves be viewed as streams). All streams can be opened, written to, read from, and closed just like in Linux. There are a few different kinds of I/O stream objects including the aforementioned (regular) files, pipes/FIFOs, and sockets, which all operate much the same way as Linux.\par
    %How Windows approaches it.
    Despite being historically separate from Unix-like operating systems, Windows approaches I/O in a startlingly familiar way. Windows too abstracts its device I/O to files, in an attempt to provide a common interface for all devices. The main difference from the previous two operating systems is, again, the standard unit of data that is passed around. Windows uses packets, called I/O Request Packets or IRPs, which can be passed between devices, and completely describes the I/O request. The goal of this design is to "allow an individual application thread to manage multiple I/O requests concurrently"\cite{russinovich_solomon_ionescu_2012}.
    I/O devices are managed by a construct called the I/O manager. When an I/O request is to be made, "The I/O manager creates an IRP in memory to represent an I/O operation, passing a pointer to the IRP to the correct driver and disposing of the packet when the I/O operation is complete"\cite{russinovich_solomon_ionescu_2012}. When the targeted device receives the IRP pointer, it dereferences the IRP in memory, performs the requested operation, then passes the IRP back to the I/O manager either because the operation is finished or more processing needs to be done by other devices.\par
    %Conclusion/transition
    Between each of the three operating systems, Linux, FreeBSD, and Windows, though they read information differently (Linux uses blocks of data, FreeBSD uses a byte stream, and Windows uses the I/O Request Packet), they perform I/O operations in the same way: through treating every data structure as a file. Each of the operating systems keeps track of their structures as a type of file, and uses different operations to read from and write to the file, so as to communicate between processes. They each support two methods of I/O, synchronous vs asynchronous (a process writes to a file while another process reads from it as data is presented vs a process can write to a file then continue its operation and another process can read from it as it needs). This theme of different yet similar perpetuates the further down the operating system one looks, and is exemplified in how the three manage process memory.\par
    %--------------------------------------------------------------
    % Memory Management
    %--------------------------------------------------------------
    %Introduce memory management
    Computer memory is crucial to the operation of modern society. Without memory, the Internet would be impossible, and modern computing would be impossible. Memory allows a computer to store process states, results, file systems, anything discussed previously and more. It typically comes in two forms: primary (typically RAM) and secondary (drives), and though there are many more types these are the ones most commonly associated with a personal computer. Memory space is limited, and therefore is a highly sought-after resource in a system. Therefore, like any resource, memory use must be managed by the controller. And again, different operating systems perform this regulation in different ways.\par
    %How Linux approaches it
    In computing, the smallest unit of data is a bit, representing a single logical binary digit. 8 bits (usually) makes a byte, a string of bytes is called a word, and a series of words makes up a page, which to Linux is usually about 4 kilobytes in size for a 32-bit architecture, and 8KB for a 64-bit architecture. The page is also the "smallest addressable unit of memory that the memory management unit (MMU) can manage" \cite{love_2014}. Linux processes do not directly address to (access) physical memory, but instead are given a 'virtual address space'. This virtual address space appears to be contiguous to the process, is directly accessible, and is organized into pages.\par
    In reality, the memory is not necessarily contiguous, but pages are instead tracked by the MMU and the kernel. This way, the system knows what memory is allocated and to what process it belongs to. However, the kernel does organize pages together into blocks based on various properties of the pages, such as access permissions \cite{love_2014}.\par
    Because virtual memory is actually larger than the available physical memory, process data is usually split between primary and secondary storage. But because secondary storage is not directly accessible, the MMU and the kernel work together to shift data between primary and secondary storage through a process called paging, which writes data from primary storage to secondary before moving the requested data from secondary storage into the expected location in primary storage. To reduce strain on hardware, the kernel attempts to coordinate with the process to only page out the data that is least likely to be used \cite{love_2014}.
    %How FreeBSD approaches it
    Like its sibling, FreeBSD utilizes a memory management unit, which again is a hardware unit that handles process addressing. Like Linux, FreeBSD has implemented a virtual memory system that allows processes to have a simple interface to physical memory. Each process is assigned a virtual address space that appears to be contiguous to the process, is most likely larger than physical memory, and most importantly unchanging.\par
    The FreeBSD MMU handles two important jobs. The first is mapping a process's call to a virtual address to a physical address, and communicating with the kernel to organize resources in such a way to make that call succeed. In a similar fashion to Linux, the MMU and kernel participate in paging as is necessary, moving necessary data from secondary storage into the location in physical memory expected by the process's virtual memory. The MMU's second function, however, is protecting multiple processes' virtual address space from each other. "When multiple processes are coresident in main memory, we must protect the physical memory associated with each process’s virtual address space to ensure that one process cannot alter the contents of another process’s virtual address space unless they explicitly choose to share parts of their address space" \cite{mckusick_neville-neil_watson_mckusick_2015}.\par
    The authors of "The Design and Implementation of the FreeBSD Operating System"\cite{mckusick_neville-neil_watson_mckusick_2015} provide interesting insight to the development of the virtual memory system of BSD, and what the potential alternatives to virtual memory addressing could have been. Specifically, in BSD4.2 the original interface planned was a function called mmap(), "that allowed unrelated processes to request a shared mapping of a file into their address spaces" \cite{mckusick_neville-neil_watson_mckusick_2015}. mmap() was never fully implemented, due to time constraints and the fact that other functions were deemed more important (such as networking in 4.2BSD).\par
    4.3BSD had a rudimentary virtual memory system, that suffered from widespread memory management hardware dependencies that made it difficult to port between computer architectures, and was not "designed to support the tightly coupled multiprocessors that were becoming increasingly common and important" \cite{mckusick_neville-neil_watson_mckusick_2015}. Eventually, the 4.3BSD virtual memory implementation was scrapped in favor of "a completely new design, on the other hand, [that] could take advantage of large memories, conserve disk transfers, and have the potential to run on multiprocessors" \cite{mckusick_neville-neil_watson_mckusick_2015}. FreeBSD implements a finely tuned version of the 4.4BSD virtual memory implementation.\par
    %How Windows approaches it
    Surprisingly, at a high level, Windows does not differ too much from its UNIX-based contemporaries. Windows processes are all allocated their own virtual address space that allows them to access physical memory. Windows too makes use of a memory manager, which performs two main functions: mapping a process's virtual addresses to physical memory, and paging data between primary and secondary storage.
    Windows begins to differ from Linux and FreeBSD in its implementation of the page structure. Processors running windows support two different page sizes of (usually) 4KB and 2MB, called small pages and large pages respectively. The actual sizes can vary depending on the computer architecture, as for example ARM large pages are 4MB. Windows utilizes large pages over small pages, mainly for the speed implications. When referencing a large page, the first reference to a byte in a large page caches "the information necessary to translate references to any other byte within the large page" \cite{russinovich_solomon_ionescu_2012}. If small pages were used, it would require more entries for the same amount of data to be referenced, which means more time must be spent looking up information in the page table.\par
    Large pages do however suffer significant drawbacks in a few different ways. First, "attempts to allocate large pages may fail after the operating system has been running for an extended period because the physical memory for each large page must occupy a significant number of physically contiguous small pages" \cite{russinovich_solomon_ionescu_2012}, because of fragmentation of physical memory. Second, memory is always non-pageable because the page file system does not support large pages" \cite{russinovich_solomon_ionescu_2012}, meaning that large pages cannot be phased in and out of primary storage. Combined, these two drawbacks mean that large pages are really only effective in memory management given a lot of free RAM, and low fragmentation rates, neither of which are guarantees in a personal computer.\par
    %--------------------------------------------------------------
    % Conclusion
    %--------------------------------------------------------------
    The best way to learn about the functionalities of the operating system is to look at a few overarching concepts such as scheduling, input/output, and memory management from the perspective of a few varied operating systems such as Linux, FreeBSD, and Microsoft Windows. Each of these OS's accomplished the same functional goal through varied means, and implemented some algorithmic or design differences. Even though Linux and FreeBSD were somewhat similar (as both are descended from UNIX), and Windows has its own distinct developmental history, each of these OS's performs the same overall function of keeping the computer operating and the user being able to interact with it, and they did so using similar paradigms. Whether that is because they are the best or most efficient approaches or the decision was made for portability's sake is unclear, but these operating systems are widely used for a reason, and it seems that they will remain so for the foreseeable future.
	\newpage
    \bibliographystyle{IEEEtran}
	\bibliography{references.bib}
\end{document}
